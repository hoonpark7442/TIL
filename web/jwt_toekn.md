- 과거의 인증방식은 주로 세션을 활용한 방식이었다. 
	- 1. 클라이언트가 id, pw로 서버에 로그인 요청
	- 2. id, pw로 인증 후 사용자 식별할 특정 유니크한 세션 id 생성하여 서버 세션저장소에 저장
	- 3. 세션 id를 특정한 형태(쿠기 혹은 json)로 클라이언트에 다시 반환
	- 4. 이후 사용자 인증이 필요한 정보를 요청할 때마다 세션 id를 쿠키에 담아 서버에 함께 전달
	- 5. 인증 필요한 api일 때 서버는 세션 id가 세션 저장소에 있는지 확인 후 있다면 인증 완료후 api 처리, 없다면 401 에러
- 이 세션은 서버에서 관리된다. 보안성은 높지만 서버 메모리에 많은 부담이 갈 수도 있다.
- 로드밸런싱 방식으로 운영될 경우 로드밸런싱 되는 서버간 세션 동기화해야하는 부담도 생긴다.
- 세션 저장소에 문제가 바랭시 인증 체계가 무너져 이전에 인증된 유저 또한 인증이 불가능해짐
- 세션id를 서버에 저장함으로써 http의 stateless함을 위배. 이로인해 scale out에 걸림돌
- 매번 요청시 세션 저장소 조회하는 로직 한번더 수행됨
- 위의 단점 극복하기 위해 jwt 등장

- 인증에 필요한 정보들을 token에 담아 암호화시켜 사용하자!
- jwt는 서명된 토큰
- 공개/개인키를 쌍으로 사용하여 토큰에 서명할 경우 서명된 토큰은 개인키를 보유한 서버가 이 서명된 토큰이 정상적인 토큰인지 인증 가능
- jwt의 구성요소
	- Header: 토큰의 타입이나 서명 생성에 어떤 알고리즘 사용되었는지 저장
	- Payload: claim이라는 사용자 혹은 토큰에 대한 property를 키-밸류 쌍으로 저장. 민감한 정보를 담아선 안된다.
	- Signature: Header, Payload 를 Base64 URL-safe Encode 를 한 값과 개인키 정보를 합친것을 헤더에서 정의한 알고리즘으로 암호화 한다.

- 작동방식
	- jwt 토큰을 클라이언트가 서버 요청시에 같이 전달
	- 서버가 가지고 있는 개인키를 가지고 Signature를 복호화한 다음 base64UrlEncode(header)가 jwt의 헤더값과 일치하는지 + base64UrlEncode(payload)와 jwt의 페이로드값과 일치하는지 확인하여 일치한다면 인증을 허용

- 장점
	- 이미 토큰 자체가 인증된 정보이기 때문에 세션저장소와 같은 별도의 인증 저장소가 필요치 않음
	- 세션과 다르게 클라이언트의 상태를 서버가 저장해두지 않아도 됨
	- Signature를 공개키/개인키 암호화를 통해 막아두었기에 데이터에 대한 보안성이 늘어남
