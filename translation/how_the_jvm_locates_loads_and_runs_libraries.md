https://blogs.oracle.com/javamagazine/post/how-the-jvm-locates-loads-and-runs-libraries 번역

> 내용이 어려워 번역도 대충 하게 되었다. 일단 참고용으로만 보자.

### 클래스로더는 jvm이 프로그램을 실행하는 방법을 이해하는 열쇠이다.

클래스는 자바 타입 시스템의 구성 요소이지만 개별적으로 로드될 수 있고 jvm프로세스를 실행할 수 있는 가장 작은 코드 조각인 컴파일 유닛이라는 또 다른 근본적인 목적을 제공한다. 
클래스 로딩 메커니즘은 자바가 처음 시작되었을 때 부터 설정되었다. 컴파일된 자바코드(클래스 파일과 패키지화된 jar파일의 형태)는 많은 운영체제에서 실행중인 jvm 프로레스에 로드될 수 있다. 
개발자가 컴파일된 라이브러리의 바이너리를 쉽게 배포할 수 있게 한 것이 바로 이 기능이다. jar 파일을 배포하는 것이 소스 코드나 플랫폼에 의존하는 바이너리보다 훨씬 쉽기 대문에 이 기능은 자바를 특히 오픈소스 프로젝트에서 인기있게 만들었다. 
이 아티클에서는 자바 클래스 로딩 메커니즘과 그 작동 방식을 자세히 설명한다. 또한 클래스 경로에서 클래스가 어떻게 발견되고 어떻게 메모리에 로드되어 초기화 되는지 역시 설명한다.

### jvm에 클래스 로딩을 하는 메커니즘

아래와 같은 간단한 자바 프로그램이 있다고 가정해보자.
```java
public class A { 
   public static void main(String[] args) {
      B b = new B();
      int i = b.inc(0); 
      System.out.println(i); 
   } 
}
```

이 코드를 컴파일하여 실행하면 jvm이 프로그램 엔트리포인트를 올바르게 결정하고 클래스 A의 주요 메서드를 실행하기 시작한다. 하지만 jvm은 모든 imported 클래스 또는 참조된 클래스를 즉시 로드하지 않는다. 특히 이는 jvm이 새로운 B()에 대한 바이트코드 명령을 만났을 때만 클래스 B를 찾고 로드하려고 한다는 것을 의미한다. 

클래스의 생성자를 호출하는 것 외에도 클래스의 정적 멤버에 액세스하거나 Reflection API를 통해 액세스하는 등 클래스를 로드하는 프로세스(the process of loading a class)를 시작하는 여러 방법들이 있다.

클래스를 실제로 로드하기 위해 jvm은 클래스로더 객체를 사용한다. 이미 로드된 모든 클래스는 클래스 로더에 대한 참조를 포함하며, 해당 클래스 로더는 해당 클래스에서 참조되는 모든 클래스를 로드하는데 사용된다. 위의 예에서 클래스 B를 로드하는 것이 대략 아래와 같이 변환될 수 있다는 의미이다.
`A.class.getClassLoader().loadClass("B")`

여기서 역설적이게도 모든 클래스 로더는 개발자가 이름으로 클래스를 찾고 로드하는 데 사용할 수 있는 java.lang.Classloader 타입의 객체이다. 
모든 jdk 클래스(예를 들어, java.lang.String)를 로드하는 첫 번째 클래스 로더가 어떻게 생성되는 지 궁금하다면, 바른 생각이다.

실제로 부트스트랩 클래스 로더라고 불리는 원시 클래스 로더는 jvm의 핵심에서 왔으며 네이티브 언어로 작성되어있다. java.lang 패키지의 클래스, 자바 기본형용 클래스 등과 같이 jvm 자체에 필요한 클래스를 로드한다. 애플리케이션 클래스는 자바로 작성된 일반 사용자 정의 클래스 로더를 사용하여 로드되므로 필요한 경우 개발자는 이러한 로더의 처리에 영향을 미칠 수 있다.


### 클래스로더 hierarchy

jvm 클래스 로더는 트리 계층으로 구성되며 모든 클래스 로더는 부모를 가진다. 클래스를 찾고 로드하기 전에 클래스 로더의 good practice는 클래스의 부모가 필요한 크래스를 로드할 수 있는지(또는 이미 로드한 상태인지) 체크하는 것이다. 

이렇게 하면 이중 작업 및 클래스 로딩을 반복적으로 수행하지 않아도 된다. 일반적으로 부모 클래스 로더의 클래스들은 자식 클래스에는 표시되지만 그 외에는 표시되지 않는다. 클래스의 위임 및 가시성을 기반으로 하는 이 구조는 계층구조에서 클래스 로더의 책임을 분리할 수 있으며 클래스 로더가 특정 위치에서만 클래스를 로드하도록 한다. 

자바 애플리케이션에서 크래스 로더의 계층을 살펴보고 일반적으로 어떤 클래스를 로드하는지 살펴보자. 계층의 루트에서는 자바가 부트스트랩 클래스 로더이다. jvm 자체를 실행하는 데 필요한 시스템 클래스를 로드한다. jdk 배포와 함께 제공된 모든 클래스가 이 클래스 로더에 의해 로드될 것으로 예상할 수 있다(개발자는 -Xbootclasspath 옵션을 사용하여 부트스트랩 클래스 로더가 로드할 수 있는 클래스 집합을 확장할 수 있다).

라이브러리가 부트 클래스패스에 배치될 수 있지만 자동으로 로드되고 초기화 되지는 않는다. 클래스는 요청 시에만 jvm에 의해 로드되므로 부트스트랩 클래스 로더에 클래스를 사용할 수 있더라도 애플리케이션에서 해당 클래스에 액세스하여 실제 로드를 트리거해야한다. 

부트스트랩 클래스 로더의 일종의 자식인 익스텐션 클래스 로더는 익스텐션 디렉터리에서 클래스를 로드하는 클래스 로더이다. 이러한 클래스는 locales, security providers 등과 같은 시스템별 컨피겨를 지정하는데에 사용될 수 있다. 익스텐션 디렉터리의 위치는 java.ext.dirs 시스템 속성을 통해 구체화된다. 이 속성은 자신의 시스템에서 다음과 같이 설정된다.

```bash
/Users/shelajev/Library/Java/Extensions:/Library/
Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/
Home/jre/lib/ext:/Library/Java/Extensions:/Network/
Library/Java/Extensions:/System/Library/Java/ 
Extensions:/usr/lib/java
````

이 속성값을 변경하여 jvm 프로셋에 로드되는 추가 라이브러리를 변경할 수 있다.

다음은 애플리케이션 클래스와 클래스 경로에서 사용할 수 있는 클래스를 로드하는 시스템 클래스 로더이다. 

익스텐션클래스 로더와 시스템 클래스 로더는 모두 URLClassloader 타입이며 부모에게 먼저 위임하고 필요한 경우 필요한 클래스를 직접 찾아서 해결하는 방식으로 동작한다.

웹 애플리케이션의 클래스 로더 계층은 좀 더 복잡하다. 여러 애플리케이션이 애플리케이션 서버에 동시에 배포될 수 있으므로 서로 클래스를 구분할 수 있어야 한다. 따라서 모든 웹 애플리케이션은 라이브러리 로드를 담당하는 자체 클래스 로더를 사용한다. 

이러한 분리를 통해 단일 서버에 배포된 서로 다른 웹 애플리케이션이 충돌없이 동일한 라이브러리의 다른 버전을 가질 수 있다. 따라서 애플리케이션 서버는 애플리케이션의 라이브러리를 로드하는 역할을 하는 자체 클래스 로더를 모든 웹 애플리케이션에 자동으로 제공한다. 이러한 arrangement는 잘 작동하는데 왜냐하면 웹 애플리케이션 클래스 로더가 부모 클래스로더에 검색을 위임하는 것 보다 먼저 애플리케이션의 WAR 파일에 패키지된 클래스를 먼저 찾으려고 하기 때문이다.


### 올바른 클래스 찾기

일반적으로 jvm에서 동일한 qualified 이름을 가진 여러 클래스를 사용할 수 있는 경우 충돌 해결 전략은 간단하고 직관적이다. 첫 번째 적절한 클래스가 승리한다. 대부분의 클래스로더가 확장되는 URLClassloader는 클래스 경로에 지정된 순서대로 디렉토리를 횡단하고 요청된 클래스 이름을 갖는 첫 번째로 찾은 클래스를 로드한다.

같은 이름을 공유하는 JAR 파일도 마찬가지이다. JAR 파일은 이름이 아닌 클래스 경로에 나타나는 순서대로 검사된다. 첫 번째 JAR 파일에 필수 클래스에 대한 항목이 포함되어 있으면 클래스가 로드된다. 그렇지 핞으면 클래스 경로 검색이 계속되어 두 번째 JAR 파일에 도달한다. 

당연히 클래스 경로에서 클래스를 찾을 수 없으면 ClassNotFound 예외가 발생한다.

일반적으로 클래스 경로의 데릭터리 순서에 의존하는 것은 취약한 작업이기 때문에 개발자는 클래스를 -Xbootclasspath 경로에 추가하여 먼저 로드되도록 할 수 있다. 이 접근 방식에는 특별히 문제가 없지만 오염된 푸트 클래스 경로에 의존하는 프로젝트를 유지하려면 작업이 필요하다.


### Resolution, Linking, and Verification

클래스를 찾고 jvm 프로세스에서 초기 인메모리 공간을 만든 후, 해당 클래스는 verified, prepared, resolved, 초기화 된다.

- Verification
	- Verification을 통해 클래스가 손상되지 않고 구조적으로 올바른지 확인한다. 

- Preparation
	- Preparation은 정적 필드를 해당 유형에 대한 기본값으로 초기화 하는 작업이 수반된다(Preparation 이후 int 유형의 필드는 0을, 참조형은 ull 등을 담게된다).

- Resolution
	- Resolution은 런타임 상수 풀의 심볼릭 참조가 실제로 요청된 타입의 유효한 클래스를 가리키는지 확인하는 것을 뜻한다. 심볼릭 참조의 Resolution은 참조된 클래스의 로드를 트리거한다. jvm 스펙에 따르면 이 Resolution 프로세스는 lazy 수행될 수 있고 클래스가 사용될 때 까지 지연된다.

- 초기화
	- 초기화에는 준비되고 검증된 클래스가 필요하다. 클래스의 이니셜라이저(..?)를 실행한다. 초기화 중에 정적 필드는 코드에 지정된 값으로 초기화 된다. 모든 정적 초기화 브록의 코드를 결합하는 정적 초기화 방식도 실행된다. 초기화 프로세스는 로드된 모든 클래스에 대해 한 번만 실행되어야 하므로 동기화된다. 특히 클래스의 초기화가 다른 클래스의 초기화를 트리거할 수 있으므로 교착 상태를 방지하기 위해 주의하여 수행해야 한다.
































