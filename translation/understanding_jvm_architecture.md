https://medium.com/platform-engineer/understanding-jvm-architecture-22c0ddf09722 번역

jvm 아키텍쳐와 자바가 실제로 작동하는 방식을 이해하는 것은 자바 생태계를 효과적으로 활용하기 위해 모든 자바 개발자에게 중요한 학습이다.
이 블로그 포스트는 jvm 내부 및 자바 에코시스템 관련 기술에 대한 탄탄한 기반을 제공할 것이다.

> 백그라운드 및 java environments는 제외

# How Java Works

자바의 강점은 WORA라는 개념으로 다양한 플랫폼에서 실행되도록 설계되었다는 것이다. C++과 같은 언어들이 특정 플랫폼과 일치하도록 소스 코드를 컴파일하고 운영체제와 하드웨어에서 네이티브로 실행하지만, 자바 소스코드는 jdk에 내장된 자바 컴파일러(javac)를 사용하여 바이트코드(.class 파일)라고 불리는 중간 상태로 컴파일된다. 이 바이트 코드는 opcode-operand 라인과 함께 16진수 형식으로 되어 있으며 jvm은 이러한 명령어를 추가 재컴파일 없이 운영체제와 기본 하드웨어 플랫폼에서 이해할 수 있는 네이티브 기계언어로 해석할 수 있다.
따라서 바이트코드는 기반 운영체제와 하드웨어 아키텍쳐에 관계없이 모든 jvm 간에 이식 가능한 플랫폼 독립적인 중간 상태로 동작한다. 그러나 jvm은 기본 하드웨어 및 운영체제 구조에서 실행되고 통신할 수 있게 개발되었으므로 운영체제 버전 및 프로세서 아키텍쳐에 적합한 jvm 버전을 선택해야 한다.

가장 핵심은 이 프로세스의 가장 중요한 구성 요소인 jvm이 프로그램 실행 중에 바이트코드를 마법처럼 해석하고 jit 컴파일 및 gc와 같은 많은 런타임 활동을 수행할 수 있는 일종의 블랙박스로만 학습되어진단 것이다. 


# jvm 아키텍쳐

jvm은 스펙에 불과하며 각 벤더마다 다르다. 우선 여기서는 일반적으로 수용되는 jvm의 아키텍쳐를 이해해보자.

![jvm-architecture](/assets/jvm-architecture-1.png)
[이미지출처](https://medium.com/platform-engineer/understanding-jvm-architecture-22c0ddf09722)<br/>


### 1. 클래스로더 서브시스템

jvm은 램에 상주한다. 실행 중에 클래스 로더 서브시스템을 사용하여 클래스 파일을 램으로 가져온다. 이를 자바 동적 클래스 로딩 기능이라 한다. 런타임(컴파일 타임이 아님)에 클래스를 처음 참조할 때 클래스 파일(.class)을 로드, 링크 및 초기화 한다.

1) 로딩
- 컴파일된 클래스(.class 파일)를 메모리에 로드하는 것은 클래스 로더의 주요 작업이다. 일반적으로 클래스로드 프로세스는 메인 클래스(즉 정적 main()에서드 선언이 있는 클래스)를 로드하는 것으로 시작된다. 모든 후속 클래스 로드 시도는 아래의 경우에 언급된 것처럼 이미 실행 중인 클래스의 클래스 참조에 따라 수행된다.
	- 바이트코드가 클래스를 정적 참조하는 경우(예: System.out)
	- 바이트코드가 클래스 객체를 생성할 때(예: Person person = new Person("john"))

(상속 속성과 연결된) 3가지 유형의 클래스 로더가 있으며 이들은 4가지 주요 원칙을 따른다.

1-1) 가시성 원칙
- 이 원리는 자식 클래스 로더가 부모 클래스 로더에 의해 로드된 클래스를 볼 수 있지만 부모 클래스 로더가 자식 클래스 로더에 의해 로드된 클래스를 찾을 수 없는 것을 말한다.

1-2) 고유성(uniqueness) 원칙
- 이 원칙은 부모에 의해 로드된 클래스가 자식 클래스 로더에 의해 다시 로드되지 않아야 하며 중복 클래스 로드가 발생하지 않도록 해야 하는 것을 말한다.

1-3) 위임 계층 원칙
- 위의 두 가지 원칙을 충족하기 위해 jvm은 각 클래스 로딩 요청에 대한 클래스로더를 선택하기 위해 위임 계층을 따른다. 가장 낮은 자식 레벨인 애플리케이션 클래스 로더에서 시작하여 수신된 클래스 로드 요청을 익스텐션 클래스 로더로 위임한 다음 익스텐션 클래스 로더는 요청을 부트스트랩 클래스 로더로 위임한다. 요청된 클래스가 부트스트랩 경로에 있으면 클래스가 로드된다. 그렇지 않으면 요청이 익스텐션 클래스로더 레벨로 다시 전송되고 익스텐션 경로 혹은 사용자 지정 경로에서 클래스를 찾는다. 또 실패하게 되면, 요청은 시스템 클래스 경로에서 클래스를 찾기 위해 애플리케이션 클래스 로더로 다시 돌아온다. 애플리케이션 클래스 로더가 요청된 클래스를 로드하지 못하면 java.lang.ClassNotFoundException 런타임에러를 발생시킨다.

1-4) No-unloading 원칙
- 클래스로더는 클래스를 로드할 수 있지만 언로드할 수는 없다. 언로딩하는 대신 현재 클래스 로더를 삭제하고 새 클래스 로더를 만들 수 있다.

![java-classloaders](/assets/java-classloaders.png)
[이미지출처](https://medium.com/platform-engineer/understanding-jvm-architecture-22c0ddf09722)<br/>


- **부트스트랩 클래스로더** 
	- 부트스트랩 클래스로더는 부트스트랩 경로에 있는 코어 자바 API 클래스와 같은 표준 jdk 클래스들을 rt.jar에서 로드한다(부트스트랩 패스 - $JAVA_HOME/jre/lib directory). C/C++ 와 같은 네이티브 언어로 구현되며 자바에서 모든 클래스로더의 부모 역할을 한다.

- **익스텐션 클래스로더**
	- 익스텐션 클래스로더는 클래스 로드 요청을 그 부모인 부트스트랩으로 위임하고, 실패하면 익스텐션 경로의 익스텐션 디렉토리(익스텐션 경로 - $JAVA_HOME/jre/lib/ext) 또는 java.ext.dirs 시스템 속성으로 지정된 기타 디렉터리에서 클래스를 로드한다. 이러한 클래스 로더는 sun.misc.Launcher$ExtClassLoader class에 의해 구현된다.

- **시스템/애플리케이션 클래스로더**
	- 시스템/애플리케이션 클래스로더는 애플리케이션에 specific한 클래스들을 시스템 클래스 경로에서 로드한다. 내부적으로 java.class.path에 매핑된 환경 변수를 사용한다. 이 클래슬 로더는 sun.misc.Launcher$AppClassLoader class에 의해 구현된다.


각 클래스로더에는 로드된 클래스를 저장하는 네임스페이스를 갖고 있다. 클래스로더가 클래스를 로드할 때 네임스페이스에 저장된 FQCN (Fully Qualified Class Name)을 기준으로 클래스를 검색하여 클래스가 이미 로드되었는지 여부를 확인한다. 클래스가 동일한 FQCN을 갖고 있지만 네임스페이스가 다른 경우에는 다른 클래스로 간주된다. 다른 네임스페이스는 클래스가 다른 클래스로더에 의해 로드되었음을 의미한다.


2) Linking

링킹은 아래의 속성들을 따르면서 로드된 클래스 또는 인터페이스, 이것들의 슈퍼클래스 및 슈퍼인터페이스, 필요에 따라 엘레먼트 타입을 verifying하고 준비하는 것을 포함한다.

- 클래스 또는 인터페이스가 연결되기 전에 완전히 로드되어야 한다.
- 클래스 또는 인터페이스는 초기화하기 전에 완전히 검증되고 준비되어야 한다.
- 링킹 중에 오류가 발생하면 프로그램이 직접 또는 간접적으로 해당 오류와 관련된 클래스 또는 인터페이스에 대한 링킹을 요구할 수 있는 지점에 던져진다(thrown)

링킹은 아래와 같이 3가지 단계로 일어난다.

- **Verification**
	- .class 파일의 정확성을 보장한다(자바 언어 사양에 따라 코드가 올바르게 작성되었는가, JVM 사양에 따른 유효한 컴파일러에 의해 생성되었는가 등). 이것은 클래스 로드 프로세스 중 가장 복잡한 테스트 프로세스이며 시간이 가장 오래 걸린다. 링킹은 클래스 로딩 프로세스를 느리게 하지만 바이트 코드를 실행할 때 이러한 검사를 여러 번 수행할 필요가 없게하므로 전체 실행을 효율적이고 효과적으로 만든다. verification이 실패하면 런타임 오류(java.lang.VerifyError)가 발생한다. 예를 들어 아래와 같은 체크들이 수행된다.

	```
	- 일관성있고 올바른 형식의 심볼 테이블
	- 재정의 되지 않은 final 메서드/클래스
	- 액세스 컨트롤 키워드를 따르는 메서드
	- 메서드의 매개 변수 수와 유형이 정확한지
	- 바이트코드가 스택을 잘못 조작하지 않는지
	- 변수가 읽히기 전에 초기화되는지
	- 변수가 올바른 유형의 값인지
	```

- **Preparation**
	- 정적 스토리지 및 메서드 테이블과 같은 jvm에서 사용하는 모든 데이터 구조에 메모리를 할당한다. 정적 필드가 생성되고 기본값으로 초기화 되지만 초기화(initialization) 과정에서 발생하는 initializer나 코드가 실행되지는 않는다.

- **Resolution**
	- 타입의 심볼릭 참조를 직접 참조로 바꾼다. 메서드 영역을 검색하여 참조된 엔티티를 찾는 방식으로 수행된다.

3) Initialization

로드된 각 클래스 또는 인터페이스의 초기화 로직이 실행된다(예: 클래스의 생성자 호출 등). JVM은 다중 스레드이기 때문에 클래스나 인터페이스의 초기화는 다른 스레드가 동일한 클래스나 인터페이스를 동시에 초기화하려고 하지 않도록 적절한 동기화를 통해 매우 신중하게 수행되어야 한다.

모든 정적 변수가 코드에 정의된 원래 값으로 할당되고 정적이 실행되는 클래스 로딩의 마지막 단계이다. 이 작업은 클래스 계층 구조의 부모에서 자식까지 클래스의 위에서 아래로 한줄 한줄 실행된다. 

* * *

### 2. Runtime Data Area

런타임 데이터 영역은 jvm 프로그램이 운영체제에서 실행될 때 할당된 메모리 영역이다. 클래스로더 서브시스템은 .class 파일을 읽는 것 외에도 해당 이진 데이터를 생성하고 각 클래스 파일에 대해 메서드 영역에 다음과 같은 정보를 저장한다.

- 로드된 클래스 및 해당 직계 부모 클래스의 Fully qualified된 이름
- .class 파일이 Class/Interface/Enum과 관련이 있는지 여부
- Modifiers, 정적변수, 메서드 정보 등

그런 다음 로드된 모든 .class 파일에 대해 java.lang package에 정의된대로 힙메모리에 클래스의 객체를 정확히 한 개를 만든다. 이 클래스 객체는 나중에 코드 안에서 클래스 레벨 정보(클래스 이름, 부모 이름, 메서드, 변수 정보, 정적 변수 등)를 읽는데에 사용될 수 있다.

1) Method Area (Shared among Threads)
메서드 영역은 각 스레드에서 공유하는 영역이다(jvm 당 하나의 메서드 영역). 모든 jvm 스레드는 동일한 메서드 영역을 공유하므로 메서드 데이터에 대한 액세스와 동적 링크 프로세스는 반드시 스레드 세이프 해야 한다.

메서드영역에는 다음과 같은 클래스 레벨의 데이터(정적 변수 포함)가 저장된다.
- 클래스로더 레퍼런스
- 런타임 상수 풀 - 숫자 상수, 필드 참조, 메서드 참조, 속성 및 각 클래스와 인터페이스의 상수 뿐만 아니라 메서드 및 필드에 대한 모든 참조를 포함한다. 메서드 또는 필드가 참조되면 jvm은 런타임 상수 풀을 사용하여 메모리 상의 메서드 또는 필드의 실제 주소를 검색한다.
- 필드데이터 - 필드별 이름, 타입, modifiers, 속성들
- 메서드 데이터 - 메서드별 이름, 리턴타입, 파라미터 타입(순서대로), modifiers, 속성들
- 메서드 코드 - 메서드별: 바이트 코드, 피연산자 스택 사이즈, 로컬 변수 사이즈, 로컬 변수 테이블, 예외 테이블, 예외테이블의 예외 핸들러별: 시작점, 끝점, 핸들러코드에 대한 pc 오프셋, 발생된 예외 클래스에 대한 컨스턴트 풀 인덱스 등

2) Heap Area (Shared among Threads)
힙 영역 역시 각 스레드에서 공유하는 영역이다(jvm 당 하나의 힙 영역). 모든 객체와 해당 인스턴스 변수 및 배열에 대한 정보가 힙 영역에 저장된다. 메서드 및 힙 영역은 여러 스레드에 대한 메모리를 공유하므로 이곳에 저장된 데이터는 스레드 세이프 하지 않다. 힙영역은 gc의 대상이다.

3) Stack Area (per Thread)
공유 리소스가 아니다. 모든 스레드가 시작되면 메서드 호출을 저장하기 위해 별도의 런타임 스택이 생성된다. 이러한 모든 메서드 호출에 대해 하나의 엔트리가 생성되고 런타임 스택의 맨 위에 추가되며 이러한 엔트리는 스택 프레임이라고 한다. 
각 스택 프레임에는 로컬 변수 배열, 피연산자 스택 및 실행 중인 메서드가 속한 클래스의 런타임 상수풀에 대한 참조가 있다. 로컬 변수 배열 및 피연산자 스택의 크기는 컴파일 하는 동안 결정된다. 따라서 스택 프레임의 크기는 메서드에 따라 고정된다. 
메서드가 정상적으로 리턴되거나 메서드 호출 중에 포착되지 않은 예외가 발생할 경우 프레임이 제거된다. 또한 예외가 발생하면 스택 추적의 각 행은 하나의 스택 프레임을 표현한다. 스택 영역은 공유 리소스가 아니므로 스레드 세이프하다.

![stack-frame](/assets/stack-frame.png)
[이미지출처](https://medium.com/platform-engineer/understanding-jvm-architecture-22c0ddf09722)<br/>

스택 프레임은 세 개의 서브 엔티티로 나뉜다.

- 로컬변수 배열 - 0부터 시작하는 인덱스가 있다. 특정 메서드에 대해 얼마나 많은 로컬변수가 포함되고 해당 값이 여기에 저장된다. 0은 메서드가 속한 클래스 인스턴스의 참조이다. 1부터 메서드로 보내진 파라미터가 저장된다. 메서드 매개 변수 뒤에 메서드의 로컬 변수가 저장된다.

- 피연산자 스택 - 요구 사항이 있는 경우 모든 중간 작업을 수행하기 위한 런타임 작업 공간 역할을 한다. 각 메서드는 피연산자 스택과 로컬 변수 배열간에 데이터를 교환하고 다른 메서드 호출 결과를 푸시하거나 팝한다. 연산자 스택 공간의 필요한 크기는 컴파일 중에 결정할 수 있다. 따라서 컴파일 중에 피연산자 스택의 크기를 결정할 수도 있다.

- 프레임 데이터 - 메서드와 관련된 모든 심볼이 여기에 저장된다. 예외의 경우, 캐치 블록 정보는 프레임 데이터에서도 유지된다.

런타임 스택프레임이기 때문에 스레드가 종료된 후 스택 프레임도 jvm에 의해 파괴된다.

스택은 동적 혹은 고정 크기일 수 있다. 만약 스레드가 허용된 것보다 더 큰 스택을 요구할 경우 StackOverflowError가 발생한다. 스레드에 새 프레임이 필요하고 할당할 만한 충분한 메모리가 없다면 OutOfMemoryError가 발생한다. 


4) PC Registers (per Thread)
각 jvm 스레드에 대해, 스레드가 시작되면, 현재 실행중인 명령의 주소(메서드 영역의 메모리 주소)를 홀드하기 위해 별도의 pc(프로그램 카운터) 레지스터가 생성된다. 현재 메서드가 네이티브이면 pc는 undefined이다. 실행이 완료되면 pc 레지스터가 다음 명령의 주소로 업데이트 된다.

5) Native Method Stack (per Thread)
자바 스레드와 네이티브 운영체제 스레드는 직접 매핑된다. 자바 스레드를 위한 모든 상태를 준비한 후 별도의 네이티브 스택이 생성되어 JNI(Java Native Interface)를 통해 호출되는 네이티브 메서드 정보(종종 C/C++로 작성됨)를 저장한다.
네이티브 스레드가 생성되고 초기화 되면 자바 스레드에서 run()메서드를 호출한다. run()메서드가 리턴되고, 포착되지 않은 예외가 처리되면 네이티브 스레드는 스레드가 스레드가 종료된 결과로 jvm을 종료해야 하는지 여부를 확인한다(즉 마지막 non-deamon 스레드인지 확인). 스레드가 종료되면 네이티브 및 자바 스레드에 대한 모든 리소스가 해제된다. 

자바 스레드가 종료되면 네이티브 스레드가 회수된다. 따라서 운영 체제는 모든 스레드를 스케쥴링하고 사용 가능한 CPU로 디스패치해야 한다.


















