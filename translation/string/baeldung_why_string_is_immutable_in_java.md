https://www.baeldung.com/java-string-immutable 번역

# 1. 소개

자바에서 스트링은 불변이다. 자바를 만든 제임스 고슬링은 인터뷰에서 언제 불변성을 사용해야 하느냐는 질문을 받았고 이에 대해 다음과 같이 답변했다.

> I would use an immutable whenever I can.

그는 또한 캐싱, 보안, 복제없는 쉬운 재사용 등 불변성이 제공하는 기능을 언급하며 자신의 주장을 뒷받침했다.

이 아티클에서는 자바 언어 설계자가 왜 스트링을 불변으로 유지하기로 결정했는지에 대한 이유를 자세히 살펴볼 예정이다.

# 2. What Is an Immutable Object?

불변 객체는 완전히 생성된 뒤에도 내부 상태가 일정하게 유지되는 객체이다. 즉 객체가 변수에 할당되면 참조를 업데이트 하거나 내부 상태를 변경할 수 없다.

불변성에 대해서는 따로 설명한 아티클이 있으니 참고바란다.
[참고](https://github.com/hoonpark7442/TIL/blob/main/translation/etc/immutable_objects_in_java.md)

# 3. Why Is String Immutable in Java?

스트링 클래스를 불변으로 유지하는 주요 이점은 캐싱, 보안, 동기화 및 성능이다.

### 3.1. Introduce to String Pool

스트링은 가장 널리 사용되는 자료구조이다. 스트링 리터럴을 캐싱하고 재사용 하면 스트링 변수가 스트링 풀에 있는 동일한 객체를 참조하기 때문에 힙공간이 많이 절약된다. String intern pool은 정확히 이 목적에 부합한다.

자바 스트링 풀은 jvm에 의해 스트링이 저장되는 특수한 메모리 영역이다. 스트링은 자바에서 불변이므로 jvm은 각 리터럴 스트링의 복사본 하나만 풀에 저장하여 할당된 메모리 양을 최적화한다. 이 프로세스를 인터닝이라 부른다.

```java
String s1 = "Hello World";
String s2 = "Hello World";
         
assertThat(s1 == s2).isTrue();
```

스트링 풀의 존재로 인해 두 개의 다른 변수가 풀에서 동일한 스트링 객체를 가리키고 있으며 그로 인해 메모리 리소스가 절약된다.

![string_intern_pool](/assets/string_intern_pool.webp)
[이미지출처](https://www.baeldung.com/java-string-immutable)<br/>

Java String Pool에 대해서는 따로 설명한 아티클이 있으니 참고바란다.


### 3.2. Security

스트링은 유저네임, 패스워드, 연결 URL, 네트워크 연결 등과 같은 민감한 정보를 저장하기 위해 자바 애플리케이션에서 널리 사용된다. 또한 클래스를 로드하는 동안 jvm 클래스로더에 의해서도 널리 사용된다.

따라서 스트링 클래스의 보안은 전체 애플리케이션 보안과 관련하여 중요하다. 예를 들어 다음과 같은 코드조각이 있다 해보자.

```java
void criticalMethod(String userName) {
    // perform security checks
    if (!isAlphaNumeric(userName)) {
        throw new SecurityException(); 
    }
	
    // do some secondary tasks
    initializeDatabase();
	
    // critical task
    connection.executeUpdate("UPDATE Customers SET Status = 'Active' " +
      " WHERE UserName = '" + userName + "'");
}
```

위의 코드 조각에서 신뢰할 수 없는 소스로부터 스트링 객체를 받았다 가정해보자. 처음에 필요한 모든 보안 검사를 수행하여 스트링이 영숫자인지 확인 후 몇 가지 작업을 더 수행한다.

신뢰할 수 없는 소스 호출자 메서드는 여전히 이 유저네임 객체에 대한 참조를 갖고 있단 점을 기억해라.

만약 스트링이 mutable하다면 업데이트를 실행할 때 보안검사를 수행한 후에도 수신된 스트링이 안전한지 확인할 수 없다. 신뢰할 수 없는 호출자 메서드는 여전히 참조를 가지고 있으며 무결성 검사를 하는 도중에 스트링을 변경할 수 있다. 따라서 변경 가능한 스트링은 시간이 지남에 따라 보안이 저하될 수 있다.

또한 스트링 유저네임이 다른 스레드에 표시될 수 으며 무결성 검사 후 값이 변경될 수도 있다.

일반적으로 이 경우 결과에 영향을 줄 수 있는 작업의 인터리빙이 적기 때문에 값이 변경되지 않을 때 중요한 코드로 작업하기가 더 쉬우므로 불변성은 이러한 케이스의 해결책이 된다.


### 3.3. Synchronization

여러 스레드로부터 액세스 되어도 값이 변하지 않기 때문에 불변성은 자동으로 스트링을 스레드 세이프하게 해준다. 

따라서 일반적으로 불변 객체는 동시에 실행되는 여러 스레드에서 공유할 수 있다. 스레드가 값을 변경하면 동일한 값을 수정하는 대신 새 스트링이 스트링 풀에 생성되기 때문에 스레드 세이프하다. 따라서 스트링은 멀티스레드에 안전하다.


### 3.4. Hashcode Caching

스트링 객체는 자료구조로 많이 사용되기 때문에 HashMap, HashTable, HashSet 등과 같은 해시 구현체에서도 널리 사용된다. 이러한 해시 구현체에서 동작할 때 bucketing을 위해 hashcode() 메서드가 상당히 자주 호출된다.

불변성은 스트링 값이 변하지 않도록 보장한다. 따라서 hashcode 메서드는 캐싱을 용이하게 하기 위해 스트링 클래스에서 오버라이드되고, 첫번째 hashcode() 콜에서 해시가 계산되어 캐시되고 그 이후 동일한 값이 리턴된다.

따라서 스트링 객체를 사용할 때 해시 구현을 사용하는 컬렉션의 성능이 향상된다.

반면 mutable 스트링은 작업 후에 스트링의 내용이 수정되면 삽입 및 검색 시 두 개의 다른 해시코드를 생성하게 되며 이로인해 맵에서 값 객체를 잃을 수도 있다.

### 3.5. Performance

앞에서 살펴본 바와 같이 스트링 풀은 스트링이 불변이기 때문에 존재한다. 따라서 힙 메모리를 절약하고 스트링으로 작업할 때 해시 구현에 대한 더 빠른 액세스를 통해 성능을 향상시킨다.

스트링은 가장 널리 사용되는 자료 구조이기 때문에 스트링 성능을 향샹시키는 것은 일반적으로 전체 애플리케이션 성능을 향상시키는데 상당한 영향을 미치게된다.

### 4. Conclusion

이 아티클을 통해 우리는 스트링이 불변이기 때문에 그들의 참조를 정규 변수로 취급할 수 있으며 스트링이 가리키는 실제 스트링 객체가 변경될지 에 대해 걱정하지 않고 메서드 혹은 스레드간 전달할 수 있다는 것을 알 수 있다.