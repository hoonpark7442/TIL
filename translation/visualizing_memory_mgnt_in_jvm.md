https://deepu.tech/memory-management-in-jvm/ 번역


# JVM 메모리 구조

아래는 JVM 프로세스에서 사용할 수 있는 메모리이며 운영 체제에서 할당한 메모리이다.
https://i.imgur.com/8uh8SPy.png

이것은 운영체제가 할당한 네이티브 메모리이며 amount는 운영체제, 프로세서, JRE에 따라 다르다.

### Heap 메모리
JVM이 객체나 동적 데이터를 저장하는 곳이다. 가장큰 메모리 블록이며 GC가 일어나는 곳이다. 
가상 시스템(VM)에 전체 힙 메모리가 커밋되지 않는다. 이 메모리 중 일부는 가상 공간으로 예약되어 있고 힙은 이를 사용하기 위해 커질 수 있기 때문이다. 
힙은 "Young"과 "Old" 세대 공간으로 나뉜다.

- young generation: young generation 혹은 "new space"는 새로운 객체가 존재하는 곳이며, "Eden space"와 "Survivor Space"로 나뉘어진다. 이 공간은 
마이너 gc에 의해 관리된다.
	- Eden Space: 새로운 객체가 생성되는 곳이다. 우리가 새로운 객체를 생성할 때 여기에 메모리가 할당된다.
	- Survivor Space: 마이너 gc에서 살아남은 객체가 저장되는 곳. S0와 S1의 두 부분으로 나뉜다.
- old generation: old generation 혹은 "tenured space"는 마이너 gc 동안 최대 테뉴어 임계값에 도달한 객체가 존재하는 곳이다. 이 공간은 메이저 gc가 관리한다.

### Thread Stacks
스택 메모리 영역이며 프로세스 안에서 스레드 당 하나의 스택메모리가 존재한다. 메소드/함수 프레임과 객체에 대한 포인터를 포함한 스레드별 정적 데이터가 저장되는 곳이다.

### Meta Space
네이티브 메모리 부분이며 디폴트로 상한선이 없다. JVM 8 버전 이전에는 PermGen으로 불리던 영역이다. 이 공간은 클래스로더가 클래스 definitions을 저장하기 위해 사용되는 공간이다. 이 공간이 계속 늘어나면 운영체제가 램에서 가상 메모리로 저장된 데이터를 이동하여 애플리케이션 속도가 느려질 수 있다. 

### Code Cache
JIT 컴파일러가 자주 접근되는 컴파일된 코드블록을 저장하는 곳이다. 일반적으로 jvm은 바이트 코드를 네이티브 머신 코드로 해석해야 하는 반면 JIT 컴팔된 코드는 네이티브 포맷으로 이미 캐시되어 있기 때문에 해석할 필요가 없다.

### Shared Libraries
여기에 사용된 공유 라이브러리의 네이티브 코드가 저장된다. 운영체제는 프로세스 당 한 번만 로드한다.



# JVM 메모리 사용 (스택 vs 힙)

이제 메모리가 어떻게 구성되어있는지 확실히 알았으므로 프로그램이 실행될 때 메모리의 가장 중요한 부분이 어떻게 사용되는지 살펴보자.
아래 자바 프로그램을 사용하자. 코드는 최적화되어있지 않으므로 불필요한 변수나 적절치 못한 수식자 등은 무시하자. 스택과 힙 메모리 사용을 시각화 하는데 중점을 두기 위해서다.

```java
class Employee {
    String name;
    Integer salary;
    Integer sales;
    Integer bonus;

    public Employee(String name, Integer salary, Integer sales) {
        this.name = name;
        this.salary = salary;
        this.sales = sales;
    }
}

public class Test {
    static int BONUS_PERCENTAGE = 10;

    static int getBonusPercentage(int salary) {
        int percentage = salary * BONUS_PERCENTAGE / 100;
        return percentage;
    }

    static int findEmployeeBonus(int salary, int noOfSales) {
        int bonusPercentage = getBonusPercentage(salary);
        int bonus = bonusPercentage * noOfSales;
        return bonus;
    }

    public static void main(String[] args) {
        Employee john = new Employee("John", 5000, 5);
        john.bonus = findEmployeeBonus(john.salary, john.sales);
        System.out.println(john.bonus);
    }
}
```

아래 주소를 통해 위의 프로그램이 어떻게 실행되고 스택과 힙 메모리가 어떻게 사용되는지 확인해보자.

https://speakerdeck.com/deepu105/jvm-memory-usage-stack-vs-heap


정리: 
- 모든 함수 콜은 스레드 스택 메모리에 프레임 블록으로서 추가된다.
- arguments 및 리턴값을 포함한 모든 로컬 변수는 스택의 함수 프레임 블록 내에 저장된다.
- int와 같은 모든 기본형 타입은 스택에 직접 저장된다.
- Employee, Integer, String과 같은 모든 객체 유형은 힙에 생성되며 스택 포인터를 사용하여 스택에서 참조된다. 정적 필드에도 적용된다.
- 현재 함수에서 호출된 함수는 스택 위에 푸시된다.
- 함수가 리턴되면 해당 프레임이 스택에서 제거된다.
- 메인 프로세스가 완료되면 힙의 객체는 스택의 포인터를 더이상 갖지 않고 orphan이 된다.
- 명시적으로 복사본을 만들지 않는 한 다른 객체 내의 모든 객체 참조는 포인터를 사용하여 수행된다. 

보는 것과 같이 스택은 자동으로 관리되며 JVM 자체가 아닌 운영체제에 의해 관리된다. 그러므로 스택에 대해 크게 걱정할 필요는 없다. 그러나 힙은 운영체제에 의해 관리되지 않으며 가장 큰 메모리 공간이고 동적 데이터를 저장하기 때문에 기하급수적으로 증가하여 시간이 지남에 따라 프로그램이 메모리를 다 사용하게 만들어 버릴 수도 있다.
또한 시간이 지남에 따라 애플리케이션 속도가 느려지면서 단편화된다. 바로 이 부분이 JVM이 도움이 되는 부분이다. garbage collection 프로세스를 사용하여 힙을 자동으로 관리하게 된다.


# JVM 메모리 관리: garbage collection

이제 jvm이 메모리를 할당하는 방법을 알게 되었으므로 애플리케이션의 성능에 매우 중요한 힙 메모리를 어떻게 자동으로 관리하는지 알아보자. 프로그램이 힙에서 자유롭게 사용할 수 있는 메모리보다 더 많은 메모리를 할당하려고 할 때 메모리 부족 에러(OOM)이 발생한다.

jvm은 gc를 통해 힙 메모리를 관리한다. 간단히 말해 새로운 객체 생성을 위한 공간을 만들기 위해 더이상 스택에서 직접적으로 혹은 간접적으로(다른 객체에서의 참조를 통해) 참조되지 않는 객체들, 즉 orpahn 객체들에 할당되어있는 메모리를 해제한다.


jvm의 gc는 다음을 담당한다.
- 운영체제로부터 메모리 할당과 다시 운영체제로의 반환
- 애플리케이션이 요청할 때 할당된 메모리를 핸들링한다.
- 할당된 메모리의 어떤 부분이 여전히 애플리케이션에서 사용 중인지 확인한다.
- 애플리케이션이 재사용할 수 있도록 사용되지 않는 메모리를 회수

jvm gc는 generational하다(세대적이다..?) (힙의 객체는 age별로 그룹화되고 서로 다른 단계에서 지워진다). 가장 일반적으로 사용되는 알고리즘은 mark & sweep 이다.


### Mark & Sweep GC

jvm은 gc를 위해 백그라운드에서 실행되는 별도의 데몬 스레드를 사용하며 특정 조건이 충족될 때 프로세스가 실행된다. Mark & Sweep GC는 일반적으로 두 단계를 포함하며 때대로 사용되는 알고리즘에 따라 옵셔널하게 세번째 단계가 있기도 하다.

http://i.imgur.com/AZaR0LP.gif


- marking: gc가 사용 중인 객체와 사용하지 않는 객체를 식별하는 첫 번째 단계이다. GC루트(스택포인터)에서 재귀적으로 도달가능하거나 사용중인 객체는 활성으로 마크된다.
- sweeping: gc는 힙을 통과하여 활성으로 마크되어있지 않은 모든 객체를 제거한다. 이렇게 제거되고 남은 공간은 비어있다고(free) 마크된다.
- compacting: 사용하지 않는 객체를 삭제 후 살아남은 모든 객체가 함께 이동된다. 이렇게 하면 단편화가 감소되고 새로운 객체에 대한 메모리 할당 성능이 향상된다.

이러한 유형의 gc는 gc를 수행하는 동안 애플리케이션에 일시 중지 시간을 도입하므로 stop-the-world gc라고도 한다.
jvm은 gc와 관련하여 선택할 수 있는 몇가지 알고리즘을 제공하며 사용하는 jdk 벤더에 따라 더 많은 옵션을 사용할 수 있다. 서로 다른 구현은 다음과 같은 서로 다른 목표에 초점을 맞춘다.

- 처리량: 애플리케이션 시간 대신 gc에 소요된 시간이 처리량에 영향을 미친다. 처리량은 높은 것이 이상적이다(즉 gc 시간이 낮은 경우)
- 일시중지시간: gc가 애플리케이션 싱행을 중지하는 기간. 일시중지기간은 이상적으로 매우 낮아야 한다.
- footprint: 사용된 힙의 크기. 이것은 이상적으로 낮게 유지되어야 한다.

### jdk 11부터 사용가능한 콜렉터

현재 LTE 버전인 jdk11을 기준으로 하기 gc를 사용할 수 있으며 사용되는 하드웨어 및 운영체제를 기준으로 jvm이 기본을 선택한다. -XX 스위치와 함께 사용할 gc도 항상 지정 가능하다.

- Serial Collector: gc에 단일 스레드를 사용하며 작은 데이터 셋을 사용하는 애플리케이션에 효율적이며 단일 프로세서에 가장 적합. XX:+UseSerialGC 스위치를 사용.
- Parallel Collector: 높은 처리량에 초점을 맞추고 있으며 gc 프로세스의 속도를 높이기 위해 여러 스레드를 사용한다. 이것은 멀티스레드/멀티프로세서 하드웨어에서 실행되는 중간에서 큰 데이터 셋을 가진 애플리케이션을 위한 것이다. XX:+UseParallelGC 스위치를 사용.
- Garbage-First(G1) Collector: G1 수집기는 대부분 동시 작업이다(비용이 비싼 작업만 동시에 수행됨). 이것은 대용량 메모리를 가진 다중 프로세서 시스템에 대한 것이며 대부분의 최신 시스템 및 운영체제에서 기본값으로 사용된다. 낮은 일시중지 시간과 높은 처리량에 중점을 둔다. XX:+UseG1GC 스위치 사용
- Z Garbage Collector: jdk11에 도입된 새로운 실험용 gc이다. 확장 가능한 짧은 대기 시간 콜렉터이다. 동시에 실행되며 애플리케이션 스레드의 실행을 중지하지 않으므로 중단되지 않는다. 짧은 대기 시간이 필요하거나 매우 큰 힙을 사용하는 애플리케이션을 대상으로 한다. XX:+UseZGC 스위치 사용.


### GC 프로세스

사용된 collector와 상관없이 jvm은 수행 시기와 장소에 따라 마이너 gc와 메이저 gc라는 두 가지 유형의 gc 프로세스를 갖고 있다.


### 마이너 gc

이 유형의 gc는 young generation 공간을 컴팩트하고 깨끗하게 유지한다. 이는 다음과 같은 조건이 충족될 때 트리거된다.
- jvm이 새 객체를 할당하는데 필요한 메모리를 eden 공간에서 가져올 수 없을 때.

처음에는 힙 공간의 모든 영역이 비어있다. eden 메모리가 가장 먼저 채워지고 그 다음은 survivor공간, 마지막으로 테뉴어 공간으로 채워진다.

마이너 gc 프로세스는 아래를 참고하자.

https://speakerdeck.com/deepu105/jvm-minor-gc

위의 슬라이드를 다시 글로 풀어보자면,

1. 시작할 때 에덴 공간에 이미 객체가 있다고 가정하자(사용된 메모리로 표시된 블록 01 ~ 06)
2. 애플리케이션이 새 객체(07)을 만든다.
3. jvm이 에덴 공간에서 필요한 메모리를 가져오려고 하지만 객체를 수용할 수 있는 사용가능 공간이 에덴에 없으므로 jvm이 마이너 gc를 트리거한다.
4. gc는 스택 포인터에서 시작하여 객체 그래프를 재귀적으로 횡단하며 사용되고 있는 메모리를 활성(used 메모리)로 표시하고, 나머지 객체를 가비지(orphan)으로 표시한다.
5. jvm은 S0와 S1 중 하나의 랜덤 블록을 "To Space"로 선택한다. S0를 선택했다고 하자. GC는 이제 모든 활성 객체를 "To Space"인 S0로 옮기고 객체들의 나이를 하나씩 증가시킨다.
6. 이제 gc가 에덴 공간을 비우고 새 객체가 에덴 공간에서 메모리를 할당 받는다.
7. 시간이 좀 지나 이제 에덴 공간에 더 많은 객체가 있다고 가정하자(사용된 메모리로 표시된 블록 07 ~ 13)
8. 애플리케이션이 새 객체를 만든다(14)
9. jvm이 에덴 공간에서 필요한 메모리를 가져오려고 하지만 객체를 수용할 수 있는 사용가능 공간이 에덴에 없으므로 jvm이 마이너 gc를 트리거한다.
10. 마크 페이즈가 반복되고 survivor 공간인 "To Space"에 있는 객체들 까지도 포함하여 활성/orphan 객체가 마크된다.
11. jvm은 이제 free 상태인 S1을 "To Space"로 선택하고 S0는 "From Space"가 된다. gc는 이제 모든 활성 객체를 에덴 공간과 "From Space"인 S0에서 "To Space"인 S1로 옮기고 나이를 증가시킨다. 몇몇 객체들은 이 공간에 맞지 않는 경우도 있기에 테뉴어 공간으로 옮겨지는데, 이는 survivor 공간이 증가(grow)할 수 없어서이며, 이러한 프로세스를 조기 프로모션이라 한다. survivor 공간 중 하나가 free인 경우에도 이러한 경우가 발생할 수 있다.
12. gc는 이제 에덴 공간과 "From Space"인 S0를 비우고 새 객체는 에덴공간에 메모리를 할당받는다.
13. 이는 각 마이너 gc에 대해 계속 반복되며 survivor들은 S0와 S1 사이에서 이동되며 나이 역시 계속 증가한다. 나이가 "최대 나이 임계값(기본값은 15)"에 도달하면 테뉴어 공간으로 이동된다.

우리는 어떻게 마이너 gc가 young generation로부터 공간을 회수하는지 보았다. 이는 stop-the-world 과정이나 굉장히 빨라서 대부분은 무시할 수 있다.

### 메이저 GC

이 유형의 gc는 테뉴어 공간을 컴팩트하고 깨끗하게 유지한다. 이는 다음 조건이 충족될 때 트리거 된다.
- 개발자가 프로그램에서 System.gc(), or Runtime.getRunTime().gc()을 호출했을 때
- jvm이 마이너 gc 사이클로 인해 계속 채워져서 테뉴어 공간이 충분치 않다고 판단할 때
- 마이너 gc 중에 jvm이 에덴 또는 survivor 공간에서 충분한 메모리를 회수할 수 없을 때
- jvm에 MaxMetaspaceSize 옵션을 설정했는데 새로운 클래스를 로드할 공간이 충분하지 않을 때

이제 메이저 gc의 프로세스를 봐보자. 마이너gc만큼 복잡하진 않다.

1. 많은 마이너 gc 사이클이 돌았고 테뉴어 공간이 거의 꽉 차서 jvm이 메이저 gc를 트리거하기로 결정했다고 가정해보자.
2. gc는 테뉴어공간에서 스택포인터에서 시작하여 객체 그래프를 재귀적으로 횡단하며 사용되고 있는 메모리를 활성(used 메모리)로 표시하고, 나머지 객체를 가비지(orphan)으로 표시한다. 만약 마이너 gc가 돌아가는 중에 메이저 gc가 트리거 된다면 프로세스는 young(에덴 & survivor) 공간도 포함한다.
3. gc가 모든 orphan 객체를 제거하고 메모리를 회수한다.
4. 메이저 gc 중에 힙에 더이상 객체가 없는 경우, jvm은 메타데이터 공간에서 로드된 클래스를 제거하여 메모리를 회수한다. 이를 full gc라고 한다.
