# static 키워드

- static 키워드로 선언하면 그 멤버는 해당 클래스의 객체가 아닌 그 클래스 자체에 속하게 된다.
- 즉 클래스의 모든 객체가 공유하는 단 하나의 인스턴스만 생성이 된다.

![static_example](/assets/static_example_1.jpeg)
[이미지출처](https://www.baeldung.com/java-static)<br/>

- 가장 가까운 예: System.out.println("Hello World")
	- out이라는 필드가 static으로 선언되어 있다. out은 PrintStream 타입의 객체이다.
- static은 왜 사용할까?
	- 모든 것을 객체 속에 둔다면 불편한 점들이 있다.
		- 예를 들어 Math.abs(-1); 절대값을 구하는 코드인데, 절대값을 구하기 위해 매번 Math의 객체를 생성해서(즉 메모리 할당을 해서) 사용할 필요가 있을까?
		- 아니면 객체 단위가 아니라 클래스 단위에서 뭔가를 하고 싶을 때. 예를 들어 객체 생성된 숫자를 센다든지..
	- 이러한 불편함을 static을 통해 해결할 수 있다.
- static 함수 호출 방법은 <클래스명>.<함수명>(); 이다. 하지만 <객체명><함수명>(); 의 방식으로도 호출이 가능하다. 어떻게 가능할까?
	- 간단하다. 객체가 아무리 많이 생성되더라도 클래스는 단 하나만 존재한다. 그러니 각 객체는 해당 static 함수를 특정할 수 있다.
	- 하지만 이러한 방식은 객체에 속한 함수인지 클래스에 속한 함수인지(변수도 마찬가지이다) 구분하기 어렵기 때문에 피해야 한다.
- 클래스에 속한 메서드가 객체에 속한 멤버(함수/변수)에 접근 불가
- 정적 변수는 힙 메모리에 저장된다.
- 정적 메서드는 컴파일 타임에 처리된다. 메서드 오버라이딩은 런타임 다형성의 일부이기 때문에 정적 메서드는 오버라이드 될 수 없다.

https://www.baeldung.com/java-static-fields-gc garbage collection 부분 번역

### 2.2. Static Fields and Class Objects

- 자바에서는 클래스 정의(class definition)도 Object이다. 클래스, 메서드 및 정적 필드 값에 대한 모든 메타 정보가 포함된다.
- 따라서 모든 static 필드는 그 static 필드가 있는 클래스 오브젝트에 의해 참조된다. 
- **따라서 클래스 객체가 존재하고 그 객체가 애플리케이션에 의해 참조될 때까지 garbage collection 대상이 되지 않는다.**
- 동시에 모든 로드된 클래스는 해당 클래스를 로드하는데 사용된 클래스로더 객체를 참조한다. (이렇게 하면 로드된 클래스들이 추적된다)
- 이러한 경우 참조 하이어라키를 가진다. 클래스로더는 모든 로드된 클래스에 대한 참조를 킵한다. 동시에 클래스 역시 클래스로더에 대한 참조를 킵한다(양방향 참조). 새 객체를 인스턴스화 할 때 마다 그 객체는 클래스 데피니션에 대한 참조를 갖고 있다.

![classloader_diagram](/assets/classloader_diagram.webp)
[이미지출처](https://www.baeldung.com/java-static-fields-gc)<br/>

- 애플리케이션이 클래스를 참조하는 동안엔 클래스를 언로드할 수 없다.
- 언제 class definition이 garbage collection대상이 되려면 무엇이 충족되어야 할까
	- 애플리케이션에서 클래스의 객체에 대한 참조가 없어야 한다. 왜냐하면 모든 객체는 그들의 객체에 대한 참조를 갖고 있기 때문이다.
	- 애플리케이션에서 이 클래스의 클래스 로더를 사용할 수 없어야 한다.
	- 클래스 자체도 애플리케이션에서 참조가 없어야 한다.

- static을 잘못 사용하게 되면 메모리릭 발생한다. 위에서 말했다시피 gc의 대상이 되기 까다롭기 때문이다. 만약 확장 가능한 자료구조, 예를 들어 ArrayList 타입이 static으로 선언되어있다면 굉장한 주의를 기울여야 한다. 