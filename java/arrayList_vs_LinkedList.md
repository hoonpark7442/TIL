# ArrayList
- ArrayList는 List 인터페이스를 구현한 구현체이며 내부적으로는 배열을 사용한다. 
- 배열은 고정된 사이즈를 갖고 있으므로 ArrayList 역시 초기 용량(기본 10)을 가진 배열을 생성한다. 
- 초기 용량을 넘어선 데이터를 저장하고자 할 때 기존 배열 크기 보다 큰 배열을 새로 생성하여 그 공간에 기존 배열의 데이터를 복사해 넣게 된다.
- 데이터 삽입
	- 일반적으로 O(1)의 시간복잡도
	- 데이터를 맨 마지막에 삽입하는 것이 아닌 중간 혹은 맨 앞에 삽입하게 된다면 최악의 경우 O(n)
	- 기본 용량이 꽉 차게 되면 새 배열을 생성해 데이터를 복사해 넣는 작업을 거치게 되며 이러한 이유로 시간복잡도는 O(n)까지 늘어나게 된다.
- 데이터 탐색
	- O(1)의 시간복잡도
- 데이터 삭제
	- 데이터 삭제 역시 삽입과 같은 시간복잡도를 갖는다
	- 맨 뒤의 데이터를 삭제하는 것은 O(1)의 시간복잡도
	- 맨 처음 혹은 중간 데이터를 삭제시에는 데이터 재배치 작업을 인해 최악의 경우 O(n)의 시간복잡도

# LinkedList
- LinkedList는 메모리 상에서 서로 떨어진 곳에 존재하는 데이터를 포인터로 연결하는 자료구조이다. 
- 그러므로 배열처럼 연속된 메모리 공간이 필요없다. 
- LinkedList는 노드로 이루어져있는데, 이 노드는 실제 값과 그 다음 혹은 이전 노드의 주소값을 가리키는 포인터로 이루어져있다. 
- 자바의 경우 doubly linked list 이며, 이는 그 전의 데이터와 다음 데이터를 가리키는 두 개의 포인터를 갖는 LinkedList를 말한다.
- 데이터 삽입
	- 시간복잡도는 O(1)
	- 하지만, 이건 삽입만의 경우이다. 만약 데이터를 중간에 삽입하거나 마지막 노드가 불명일 경우, 헤드 노드에서부터 탐색을 해야 하기에 최악의 경우 탐색시간을 합친 O(n)의 시간복잡도가 걸리게 된다.
- 데이터 탐색
	- 데이터를 탐색하기 위해서는 헤드 노드에서부터 찾고자 하는 데이터까지 차례대로 탐색해 나가야 한다. 
	- 시간복잡도는 최악의 경우 O(n)
- 데이터 삭제
	- 데이터 삽입과 마찬가지로 삭제 자체는 unlink 과정만 거치면 되므로 O(1)의 시간복잡도를 갖는다. 
	- 하지만 탐색이 추가되면 최악의 경우 O(n)의 시간복잡도가 걸리게 된다.

# ArrayList vs LinkedList
- 데이터 탐색이 더 많은 작업이라면 ArrayList를 선택하는 것이 현명
- ArrayList에 들어갈 데이터의 최대 용량을 알고 있다면 더욱 ArrayList를 사용하길 권장한다. 
- ArrayList 초기화 때 해당 용량만큼 배열을 할당받으면 되기 때문에 기존 배열을 복사해 넣는 연산을 최소화 할 수 있다.

- 반대로 데이터의 삽입/삭제 작업이 많은 경우 LinkedList가 더 현명한 선택일 수 있다.
- ArrayList는 위에서 말했듯이, 삽입, 삭제시 데이터 재배치 연산이 일어날 수 있고, 초기 용량을 넘어서게 되면 배열 재할당이라는 부가적인 연산까지 일어날 수 있다.
- 더군다나 ArrayList는 자주 삭제가 일어나게 되면 그 공간만큼 메모리 낭비가 발생

- 메모리 측면에서 LinkedList가 더 효율적이다 할 수는 없을 것 같다. ArrayList와 달리 LinkedList는 값 뿐만 아니라 앞 뒤의 데이터를 연결하기 위한 포인터 역시도 저장해야 하므로 추가적인 메모리할당이 필요하기 때문이다.

블로그: https://velog.io/@destiny1616/ArrayList-vs-LinkedList

