# 인터페이스와 추상클래스

- 추상클래스
	- 연관성 있는 서브클래스가 갖는 공통적인 기능들을 한 곳에 모아두고 이를 상속받는다.
	- 상속받은 일반클래스에서 추상클래스의 추상메서드를 반드시 오버라이드해야 한다. 이때 자신만의 비즈니스로직에 맞게 구현한다.
		- 예) 베이스 파일리더기 추상클래스에 printLine 추상메서드 -> LowerCaseFileReader, UpperCaseFileReader는 베이스 파일리더기를 extend하고 각자 pringLine 메서드를 그들의 비즈니스 로직에 맞게 오버라이드한다.
	- 즉 기능을 확장
	- Is-A 관계

- 인터페이스
	- 추상클래스보다 한 단계 더 추상화
	- 기능의 확장보다는 구현객체가 동일한 기능을 보장하는 것에 목적
	- static final 필드만 가질 수 있다. 필드 선언시 public static final이 생략되어있다고 생각해라.
	- 다중 상속 가능
	- Is-Able-To 관계

- 예제
	- 생명체 추상클래스 아래 휴먼과 애니멀 추상클래스 있다고 하자 휴먼을 확장하는 Hoon 클래스가 있다. Animal을 확장하는 거북이 클래스가 있다. 
	- talkable, swimmable 인터페이스도 있다. talkable은 휴먼에서 구현한다 치면 swimmable은 어디서 구현할까? 모든 생명체가 수영을 할 수 있는건 아니다. 모든 휴먼이, 모든 애니멀이 수영할 수 있는건 아니다. Hoon은 수영을 할 수 있다고 해보자. 그럼 Hoon과 거북이 클래스에서 해당 인터페이스를 구현한다.
	- 생명체는 나이를 먹고 움직인다. 이는 전 생명체 동일이므로 일반 메서드로 선언해준다. 
	- attack 메서드는 추상메서드로 선언하자. 각 클래스에서 오버라이드해서 그 각자의 비즈니스로직에 맞게 정의한다.
	- 휴먼 클래스에서 생명체 추상클래스를 확장하고 talkable 인터페이스를 구현한다.
	- 그러므로 휴먼 클래스에서 attack 메서드와 talkable의 talk 메서드를 비즈니스 로직에 맞게 실제 구현한다.
	- 애니멀 클래스에서도 attack 메서드를 재정의 해준다. 
	- Hoon과 거북이 클래스에서는 swimmable 인터페이스의 추상메서드인 스윔 메서드를 구현해준다. 
	- 그런데 Hoon은 일도 할 수 있다. workable 인터페이스를 추가로 구현하여 워크 메서드를 구현한다. Hoon 클래스는 2개의 인터페이스를 구현하며 다중상속을 하게 되었다.

- 인터페이스와 추상클래스 공통점
	- 인스턴스화 할 수 없다.
	- 자식 클래스가 무언가 반드시 구현하도록 위임해야할 때 사용.
	- 추상클래스, 인터페이스 모두 상속받은 자식클래스에서 추상메서드를 오버라이딩 하여 구현부 작성했을 때 비로소 사용가능한 객체가 된다.

- 인터페이스와 추상클래스 차이점
	- 추상클래스는 단일 상속, 인터페이스는 다중 상속 가능
	- 추상클래스의 목적은 상속을 받아서 **기능을 확장** 시키는 것
	- 인터페이스의 목적은 구현하는 모든 클래스에 대해 특정한 메서드가 반드시 존재하도록 강제하는 역할(부모로부터 유전자를 물려받는 것이 아니라 사교적으로 필요에 따라 결합하는 관계). 즉 구현객체가 **같은 동작을 한다는 것을 보장** 하기 위함


- 사용시기
	- 추상클래스
		- 관련성 높은 클래스간 코드를 공유하고 싶은 경우
		- 추상 클래스를 상속 받을 클래스들이 공통으로 가지는 메서드와 필드가 많거나 public 이외의 접근자(protected, private) 선언이 필요한 경우
		- 객체 상태를 수정하기 위해 non-final나 non-static 메서드를 원할 경우
	- 인터페이스
		- 서로 관련성 없는 클래스들이 특정 기능을 공유할 필요 있을 경우
			- ex) Comparable, Cloneable 인터페이스는 여러 클래스들에서 구현되는데 구현클래스들 간에 관련성없다.
		- 특정 데이터 타입의 행동을 명시하고 싶은데 어디서 그 행동이 구현되는지는 신경쓰지 않는 경우(마커 인터페이스)
		- 다중상속 허용하고 싶은 경우