https://blog.saeloun.com/2022/04/12/ruby-variable-width-allocation.rb.html

## RValue
- 동적 메모리 할당을 위해 루비는 힙 메모리를 사용하고, 힙의 기본단위를 슬랏이라 부른다.
- 각 슬롯은 RValue를 갖고 있다. 
- RValue는 40bytes로 되어 있고 모든 타입 객체를 담을 수 있다. 
- 40바이트 중에서 첫 8바이트는 플래그, 다음 8바이트는 클래스 포인터를 위한 자리다. 나머지 24바이트는 object-specific 정보를 담는다. 
- 클래스 객체라면 extension object의 포인터를, 스트링이면 그 값을 담는다.

## Heap Pages
- 이 40바이트 슬롯은 힙페이지로 묶인다. 힙페이지는 16kb의 메모리 컨테이너이며 각 힙 페이지는 약 408~409개의 슬롯을 갖는다.
- 한 힙페이지에 있는 모든 슬롯은 연속적이고 갭이 없다.

## Freelist
- **힙페이지가 생성될 때** 모든 슬롯은 T_NONE이라는 타입의 RValue로 채워진다. 이는 빈슬롯이란 것을 의미하며 오직 플래그와 next로 알려져있는 Klass pointer 를 담고 있다. (아마도..원문에는 그냥 this라고 나와있는데 이게 뭘 가리키는건지 몰겠지만 아마도 next일거같다...)이 next라는 Klass pointer는 다른 RVALUE를 가리킨다.
![](/assets/freelist.png)
- **힙페이지가 초기화 될 때** 루비는 freelist 포인터를 첫번째슬롯의 주소로 설정하고, 각 슬롯을 방문하기 시작한다. 
- 각 슬롯에 점차 도달하면, freelist 포인터를 현재 슬롯의 주소로 설정하고, 현재 슬롯의 next 포인터를(아마 Klass pointer를 말하는거아닐까싶다) 이전 슬롯의 주소로 설정한다.(이것도 잘 모르겠다. 이름은 next인데 왜 이전 슬롯 주소로 설정하나..?next란걸 없애고 이전 슬롯주소로 대체한단건가?)
	- 아 음 그니까 뒤에서 부터 채워넣나? 그러니 previous 주소지만 예를 들어 맨마지막 슬롯에 채워놓고 그 다음 프리리스트 포인터는 그 전 주소로 옮겨가게 되고, 결국 의미상 백워드여도 next긴 하니까..?
- FreeList라는 빈 슬롯의 링크드리스트를 만들어 마지막 방문에서 이전 슬롯 주소를 얻는다.(잘 이해가 안됨)
	- 그러니까 빈 슬롯들의 링크드리스트를 만들고, 마지막 방문한 데에서 전 슬롯의 주소를 가져온다? 잘 모르겠다.
	- 빈 슬롯들의 링크드리스트를 만들고, 맨 마지막 노드에서 이전 빈슬롯의 주소를 가져올 수 있다. 맞나, 잘 몰겠다.

## Allocating an object
- 객체를 할당할 필요가 있을 때, 루비는 힙 페이지에 빈 슬롯의 주소를 요청한다. 그러면 힙 페이지는 항상 freelist 포인터를 리턴한다. 
- 이 포인터에는 빈 슬롯의 주소가 담겨있다. 
- 그리고 freelist 포인터를 next 빈 슬롯의 주소로 업데이트한다(next라고 되어있지만 이전 슬롯의 주소이다.)
- 그리고 현재 빈 슬롯을 freelist로부터 unlink한다.
- 이러한 과정을 통해 루비는 객체를 할당한다.
- freelist를 사용하면 객체할당 작업을 상수시간내에 달성 가능하다. 
- 루비가 빈 슬롯을 요청할 때 마다, 힙페이지는 그저 freelist 포인터 밸류를 체크하고 이 주소를 루비에 리턴한다.

할당전 
![](/assets/freelist1.png)

Rclass 타입 할당
![](/assets/freelist2.png)

RString 타입 할당
![](/assets/freelist3.png)

RArray 타입 할당
![](/assets/freelist4.png)

- 슬롯이 모두 채워지면, gc가 작동하여 비활성 객체에서 공간을 회수한다.

## Garbage collection
- 루비는 Mark-Sweep-Compact gc 알고리즘을 사용한다. 
- gc가 활성화될 때, 루비코드는 실행이 불가능해진다. stop the world

### GC Phase

**Marking**
- 어떤 객체가 살아남고, 어떤게 freed 될수 있는지를 결정하는 단계이다.
- 먼저 root-like 객체들, 글로벌 변수나 클래스 등과 그들의 자식들을 마크한다. 이 작업은 마크 stack이 빌 때 까지 계속된다.
- 예를 들어보자

- 4개의 슬롯을 가진 2개의 힙 페이지가 있다 하자. 검정 슬롯은 마크된 슬롯이고 화살표는 참조를 나타낸다. 예를들어 A->G 라 하면 A가 G 객체를 참조하고 있는 것이다

![](/assets/mark1.png)

- A,B가 루트 엘레먼트라 해보자. A,B가 마크 스택에 push된다. 
- A를 스택에서 pop한다. 마크를 하고, A의 자식, 즉 G를 스택에 넣는다.
- B를 pop한다. B를 마크하고 B의 자식인 E를 마크 스택에 넣는다. 
- 마크스택이 빌 때 까지 이를 반복한다.
- (스택에 넣지만 큐처럼 작동하는거같다.)
- 마크 작업이 끝나면 sweep phase로 넘어간다.

![](/assets/mark2.gif)


**Sweeping**
- 모든 마크되지 않은 객체들이 gc에 의해 해제되는 단계이다.
- 마크가 된 후의 힙 페이지의 모습은 아래와 같다.

![](/assets/sweep1.png)

- 이제 gc는 모든 힙페이지들을 스캔하고, unmarked 객체를 확인한 후, 공간을 확보한다. 우리의 예제에서는 C,F가 unmarked되어있으므로 GC는 이 공간들을 회수한다.

![](/assets/sweep2.png)


**Compaction**
- Compaction은 객체들이 담겨있는 슬롯과 빈 슬롯을 재정렬하는 과정이다. 
- Compaction은 힙페이지 내의 객체들을 힙페이지의 시작 부분으로 이동시키는 과정이다. 이는 메모리사용량 감소, GC 속도 향상, 쓰기 성능 향상 등의 다양한 이점을 제공한다.
- 2 스텝으로 이뤄져있다.

- compact step
	- 2개의 커서를 사용한다. Free 커서는 앞으로, Compact 커서는 뒤방향으로 움직인다. 2 fingers algorithm이라고도 불린다. 2 커서가 만나게 되면 스텝은 종료된다.
	- 먼저 프리커서가 첫번째 빈 슬롯까지 이동한다. 빈 슬롯까지 이동하였다면 컴팩트 커서는 힙 맨 뒤에서부터 시작하여 역방향으로 움직이며 첫번째 filled 슬롯까지 이동한다. 
	- 첫번째 filled 슬롯까지 이동했다면 해당 객체를 free 커서가 있는 빈 슬롯으로 옮기고 컴팩트 커서가 있던 슬롯에 어디로 옮겼는지에 대한 정보를 남겨둔다. 
	- 위의 과정을 두 커서가 만날 때 까지 진행한다. 
	- compact 과정이 끝나면 아래와 같이 된다.
	![](/assets/compact.gif)

- update reference step
	- 컴팩트 전의 객체간 참조 정보를 업데이트하는 과정이다.
	- 아래는 컴팩트 과정이 끝난 직후의 모습이다. A,B의 참조 정보가 아직 업데이트 되어 있지 않다.
	![](/assets/refer1.png)
	
	- 해당 단계에서는 하나의 커서만 존재한다. 모든 객체를 선형적으로 스캔하며 컴팩트 과정에서 포워딩된 객체의 슬롯을 가리키고 있다면, 미리 남겨둔 이동 정보를 바탕으로 참조정보를 업데이트 해준다. 최종적으로 아래와 같이 된다
	![](/assets/refer2.png)